#include <iostream>
#define OK 1
#define ERROR 0
#define OVERFLOW -2

using namespace std;


//栈的标准操作
Status InitStack(LinkStack &S);
bool StackEmpty(LinkStack S);
Status Push(LinkStack &S, SElemType e);
Status Pop(LinkStack &S, SElemType &e);
SElemType GetTop(LinkStack &S);

bool In(char ch);
char Precede(char theta1, char theta2);
char Operate(char first, char theta, char second);
char EvaluateExpression(char *);


const char oper[7] = {'+', '-', '*', '/', '(', ')', '#'};

typedef char SElemType;

typedef int Status;

typedef struct StackNode
{
    int data;
    struct StackNode *next;
} StackNode, *LinkStack;

Status InitStack(LinkStack &S)
{
    S->next = NULL;
}

bool StackEmpty(LinkStack S)
{
    if (S->next == NULL)return true;
    else return false;
}

Status Push(LinkStack &S, SElemType e)
{
    StackNode tem = new StackNode;
    tem->data = e;
    tem->next = S->next;
    S->next = tem;
}

Status Pop(LinkStack &S, SElemType &e)
{
    if (!StackEmpty(S))
    {
        e = S->data ;
        S->next = S->next->next;
        return 1;
    }
    else return 0;
}

SElemType GetTop(LinkStack &S)
{
    return S->data;
}


char Precede(char theta1, char theta2)
{
    if (theta1 == '+' || theta1 == '-' && 
    (theta2 == '*' || theta2 == '/' || theta2 == '('))return '<';
    if (theta1 == '+' || theta1 == '-' && 
    (theta2 == '+' || theta2 == '-' || theta2 == ')' || theta2 == '#'))return '>';
    if (theta1 == '*' || theta1 == '/' && theta2 != '(')return '>';
    if (theta1 == '*' || theta1 == '/' && theta2 == '(')return '<';
    if (theta1 == '('  && theta2 != ')')return '<';
    if (theta1 == ')')return '>';
    if (theta1 == '#' && theta2 != '#')return '<';
    if (theta1 == '#' && theta2 == '#')return '=';


}

char Operate(char first, char theta, char second)
{
    if (theta == '+')return (first-'0' + second -'0')+'0';
    if (theta == '-')return (first-'0' - second +'0')+'0';
    if (theta == '*')return ((first-'0') * (second -'0'))+'0';
    if (theta == '/')return ((first-'0') / (second -'0'))+'0';
}

char EvaluateExpression(char *)
{
    LinkStack opnd = new (StackNode);
    LinkStack optr = new (StackNode);
    InitStack(opnd);
    InitStack(optr);
    Push(optr,'#');
    cin>>ch;
    while(ch != '#' && GetTop(optr) != '#')
    {
        if (!In(CH)){Push(opnd,ch);cin>>ch;}
        else 
        {
            switch(Precede(GetTop(optr),ch))
            {
                case '<':
                Push(optr,ch);cin>>ch;
                break;
                case '>':
                Pop(optr,theta);
                Pop(opnd,b);Pop(opnd,a);
                Push(opnd,Operate(a,theta,b));
                break;
                case '=':
                Pop(optr,x);cin>>ch;
                break;
            }
        }
    }
    return GetTop(opnd);
}

bool in(char ch)
{
    for(int i = 0;i < 7;i ++)
        if (ch == oper[i])return true;
    return false;
}

int main()
{
    int mode;
    cin >> mode;
    char chs[80];
    bool TestOther(int);
    switch (mode)
    {
        case 4:
            cin >> chs;
            cout << EvaluateExpression(chs) - 48 << endl;
            break;
        default:
            TestOther(mode);
    }
    return 0;
}
